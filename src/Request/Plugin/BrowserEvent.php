<?php/** * BrowserEvent.php - Xajax browser event * * This class adds server side event handling capabilities to Xajax * * Events can be registered, then event handlers attached. * * @package xajax-core * @author Jared White * @author J. Max Wilson * @author Joseph Woolley * @author Steffen Konerow * @author Thierry Feuzeu <thierry.feuzeu@gmail.com> * @copyright Copyright (c) 2005-2007 by Jared White & J. Max Wilson * @copyright Copyright (c) 2008-2010 by Joseph Woolley, Steffen Konerow, Jared White  & J. Max Wilson * @copyright 2016 Thierry Feuzeu <thierry.feuzeu@gmail.com> * @license https://opensource.org/licenses/BSD-2-Clause BSD 2-Clause License * @link https://github.com/lagdo/xajax-core */namespace Xajax\Request\Plugin;use Xajax\Xajax;use Xajax\Plugin\Request as RequestPlugin;class BrowserEvent extends RequestPlugin{	use \Xajax\Utils\ContainerTrait;	/**	 * The registered browser events	 *	 * @var array	 */	protected $aEvents;	/**	 * The name of the event that is being requested (during the request processing phase)	 *	 * @var string	 */	protected $sRequestedEvent;	public function __construct()	{		$this->aEvents = array();		$this->sRequestedEvent = NULL;		if(isset($_GET['xjxevt']))		{			$this->sRequestedEvent = $_GET['xjxevt'];		}		if(isset($_POST['xjxevt']))		{			$this->sRequestedEvent = $_POST['xjxevt'];		}	}	/**	 * Return the name of this plugin	 *	 * @return string	 */	public function getName()	{		return 'BrowserEvent';	}	/**	 * Register a browser event	 *	 * @param array 		$aArgs				An array containing the event specification	 *	 * @return \Xajax\Request\Request	 */	public function register($aArgs)	{		if(count($aArgs) > 1)		{			$sType = $aArgs[0];			if($sType == Xajax::BROWSER_EVENT)			{				$sEvent = $aArgs[1];				if(!isset($this->aEvents[$sEvent]))				{					$xBrowserEvent = new \Xajax\Support\BrowserEvent($sEvent);					if(count($aArgs) > 2 && is_array($aArgs[2]))					{						foreach($aArgs[2] as $sKey => $sValue)						{							$xBrowserEvent->configure($sKey, $sValue);						}					}					$this->aEvents[$sEvent] = $xBrowserEvent;					return $xBrowserEvent->generateRequest();				}			}			else if($sType == Xajax::EVENT_HANDLER)			{				$sEvent = $aArgs[1];				if(isset($this->aEvents[$sEvent]) && isset($aArgs[2]))				{					$xUserFunction = $aArgs[2];					if(!($xUserFunction instanceof \Xajax\Support\UserFunction))					{						$xUserFunction = new \Xajax\Support\UserFunction($xUserFunction);					}					$objEvent = $this->aEvents[$sEvent];					$objEvent->addHandler($xUserFunction);					return true;				}			}		}		return false;	}	/**	 * Generate a hash for the registered browser events	 *	 * @return string	 */	public function generateHash()	{		$sHash = '';		foreach($this->aEvents as $xEvent)		{			$sHash .= $xEvent->getName();		}		return md5($sHash);	}	/**	 * Generate client side javascript code for the registered browser events	 *	 * @return string	 */	public function getClientScript()	{		$sCode = '';		foreach($this->aEvents as $xEvent)		{			$sCode .= $xEvent->getClientScript();		}		return $sCode;	}	/**	 * Check if this plugin can process the incoming Xajax request	 *	 * @return boolean	 */	public function canProcessRequest()	{		// Check the validity of the event name		if(($this->sRequestedEvent) && !$this->validateEvent($this->sRequestedEvent))		{			$this->sRequestedEvent = null;		}		return ($this->sRequestedEvent != NULL);	}	/**	 * Process the incoming Xajax request	 *	 * @return boolean	 */	public function processRequest()	{		if(!$this->canProcessRequest())			return false;		$aArgs = RequestManager::getInstance()->process();		if(array_key_exists($this->sRequestedEvent, $this->aEvents))		{			$this->aEvents[$this->sRequestedEvent]->fire($aArgs);			return true;		}		// Unable to find the requested event		throw new \Xajax\Exception\Error('errors.events.invalid', array('name' => $this->sRequestedEvent));	}}