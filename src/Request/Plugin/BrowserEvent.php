<?phpnamespace Xajax\Request\Plugin;use Xajax\Xajax;use Xajax\Plugin\Request as RequestPlugin;/*	File: BrowserEvent.php	Contains the BrowserEvent class	Title: BrowserEvent class	Please see <copyright.php> for a detailed description, copyright	and license information.*//*	@package Xajax	@version $Id: BrowserEvent.php 362 2007-05-29 15:32:24Z calltoconstruct $	@copyright Copyright (c) 2005-2007 by Jared White & J. Max Wilson	@copyright Copyright (c) 2008-2009 by Joseph Woolley, Steffen Konerow, Jared White  & J. Max Wilson	@license http://www.xajaxproject.org/bsd_license.txt BSD License*//*	Class: BrowserEvent		Plugin that adds server side event handling capabilities to xajax.	Events can be registered, then event handlers attached.*/class BrowserEvent extends RequestPlugin{	use \Xajax\Utils\ContainerTrait;	/*		Array: aEvents	*/	protected $aEvents;	/*		String: sRequestedEvent	*/	protected $sRequestedEvent;	/*		Function: __construct	*/	public function __construct()	{		$this->aEvents = array();		$this->sRequestedEvent = NULL;		if(isset($_GET['xjxevt']))		{			$this->sRequestedEvent = $_GET['xjxevt'];		}		if(isset($_POST['xjxevt']))		{			$this->sRequestedEvent = $_POST['xjxevt'];		}	}	/*		Function: getName	*/	public function getName()	{		return 'BrowserEvent';	}	/*		Function: register		$sType - (string): type of item being registered		$sEvent - (string): the name of the event		$ufHandler - (function name or reference): a reference to the user function to call		$aConfiguration - (array): an array containing configuration options	*/	public function register($aArgs)	{		if(count($aArgs) > 1)		{			$sType = $aArgs[0];			if($sType == Xajax::BROWSER_EVENT)			{				$sEvent = $aArgs[1];				if(!isset($this->aEvents[$sEvent]))				{					$xBrowserEvent = new \Xajax\Support\BrowserEvent($sEvent);					if(count($aArgs) > 2 && is_array($aArgs[2]))					{						foreach($aArgs[2] as $sKey => $sValue)						{							$xBrowserEvent->configure($sKey, $sValue);						}					}					$this->aEvents[$sEvent] = $xBrowserEvent;					return $xBrowserEvent->generateRequest();				}			}			else if($sType == Xajax::EVENT_HANDLER)			{				$sEvent = $aArgs[1];				if(isset($this->aEvents[$sEvent]) && isset($aArgs[2]))				{					$xUserFunction = $aArgs[2];					if(!($xUserFunction instanceof \Xajax\Support\UserFunction))					{						$xUserFunction = new \Xajax\Support\UserFunction($xUserFunction);					}					$objEvent = $this->aEvents[$sEvent];					$objEvent->addHandler($xUserFunction);					return true;				}			}		}		return false;	}	public function generateHash()	{		$sHash = '';		foreach($this->aEvents as $xEvent)		{			$sHash .= $xEvent->getName();		}		return md5($sHash);	}	/*		Function: getClientScript	*/	public function getClientScript()	{		$sCode = '';		foreach($this->aEvents as $xEvent)		{			$sCode .= $xEvent->getClientScript();		}		return $sCode;	}	/*		Function: canProcessRequest	*/	public function canProcessRequest()	{		// Check the validity of the event name		if(($this->sRequestedEvent) && !$this->validateEvent($this->sRequestedEvent))		{			$this->sRequestedEvent = null;		}		return ($this->sRequestedEvent != NULL);	}	/*		Function: processRequest	*/	public function processRequest()	{		if(!$this->canProcessRequest())			return false;		$aArgs = RequestManager::getInstance()->process();		if(array_key_exists($this->sRequestedEvent, $this->aEvents))		{			$this->aEvents[$this->sRequestedEvent]->fire($aArgs);			return true;		}		// Unable to find the requested event		throw new \Xajax\Exception\Error('errors.events.invalid', array('name' => $this->sRequestedEvent));	}}